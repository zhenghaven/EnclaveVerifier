/// Types that can be serialized to bytecode.
pub trait Serializible
{
	/// Serialize the AST into serials of bytes, and return the vector of bytes.
	///
	/// If the process failed, an error message will be returned. However, this
	/// process should not be normally failed if there is enough memory space,
	/// and the AST is only constructed with provided functions/methods.
	///
	fn to_bytes(&self) -> Result<Vec<u8>, String>;
}

/// Types that can be deserialized from bytecode.
pub trait Deserializible<T>
{
	/// Deserialize the bytecode to re-construct the AST.
	///
	/// The function should return a tuple of a slice of bytes that is left from
	/// the deserialize process, and the AST. If the process failed, an error
	/// message will be returned instead.
	///
	/// However, this process should not be normally failed if there is still enough
	/// memory space, the bytecode is generated by Serializible::to_bytes, and the
	/// bytecode is not corrupted.
	///
	fn from_bytes(bytes : &[u8]) -> Result<(&[u8], T), String>;
}

pub enum IndentString
{
	Enter,
	Stay(String),
	Exit,
}

pub fn indent_lines_to_string(in_lines : &Vec<IndentString>, indent_ch : char) -> String
{
	let mut res : String = String::new();
	let mut indent : String = String::new();

	for line in in_lines.iter()
	{
		match line
		{
			IndentString::Enter =>
			{
				res = res + &indent + "{\n";
				indent.push(indent_ch);
			},
			IndentString::Stay(s) =>
			{
				res = res + &indent + s + "\n";
			},
			IndentString::Exit =>
			{
				indent.pop();
				res = res + &indent + "}\n";
			},
		}
	}

	res
}

pub mod primit_serialize;

pub mod data_type;
pub mod var_general;
pub mod exp;
pub mod func_general;
pub mod aexp;
pub mod bexp;
pub mod cmd;
